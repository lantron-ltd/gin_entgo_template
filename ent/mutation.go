// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"myetc.lantron.ltd/m/ent/etcrecord"
	"myetc.lantron.ltd/m/ent/etcsyncrecord"
	"myetc.lantron.ltd/m/ent/etcuser"
	"myetc.lantron.ltd/m/ent/predicate"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeETCRecord     = "ETCRecord"
	TypeETCSyncRecord = "ETCSyncRecord"
	TypeETCUser       = "ETCUser"
)

// ETCRecordMutation represents an operation that mutates the ETCRecord nodes in the graph.
type ETCRecordMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	username          *string
	entry             *string
	entry_year        *int32
	addentry_year     *int32
	entry_month       *int32
	addentry_month    *int32
	entry_day         *int32
	addentry_day      *int32
	exit              *string
	exit_date         *string
	exit_time         *string
	total_price       *int32
	addtotal_price    *int32
	discount_price    *int32
	adddiscount_price *int32
	paid_price        *int32
	addpaid_price     *int32
	car_type          *int8
	addcar_type       *int8
	car_number        *string
	card_number       *string
	status            *string
	comment           *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ETCRecord, error)
	predicates        []predicate.ETCRecord
}

var _ ent.Mutation = (*ETCRecordMutation)(nil)

// etcrecordOption allows management of the mutation configuration using functional options.
type etcrecordOption func(*ETCRecordMutation)

// newETCRecordMutation creates new mutation for the ETCRecord entity.
func newETCRecordMutation(c config, op Op, opts ...etcrecordOption) *ETCRecordMutation {
	m := &ETCRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeETCRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withETCRecordID sets the ID field of the mutation.
func withETCRecordID(id int64) etcrecordOption {
	return func(m *ETCRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *ETCRecord
		)
		m.oldValue = func(ctx context.Context) (*ETCRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ETCRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withETCRecord sets the old ETCRecord of the mutation.
func withETCRecord(node *ETCRecord) etcrecordOption {
	return func(m *ETCRecordMutation) {
		m.oldValue = func(context.Context) (*ETCRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ETCRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ETCRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ETCRecord entities.
func (m *ETCRecordMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ETCRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ETCRecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ETCRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *ETCRecordMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ETCRecordMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *ETCRecordMutation) ResetUsername() {
	m.username = nil
}

// SetEntry sets the "entry" field.
func (m *ETCRecordMutation) SetEntry(s string) {
	m.entry = &s
}

// Entry returns the value of the "entry" field in the mutation.
func (m *ETCRecordMutation) Entry() (r string, exists bool) {
	v := m.entry
	if v == nil {
		return
	}
	return *v, true
}

// OldEntry returns the old "entry" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldEntry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntry: %w", err)
	}
	return oldValue.Entry, nil
}

// ResetEntry resets all changes to the "entry" field.
func (m *ETCRecordMutation) ResetEntry() {
	m.entry = nil
}

// SetEntryYear sets the "entry_year" field.
func (m *ETCRecordMutation) SetEntryYear(i int32) {
	m.entry_year = &i
	m.addentry_year = nil
}

// EntryYear returns the value of the "entry_year" field in the mutation.
func (m *ETCRecordMutation) EntryYear() (r int32, exists bool) {
	v := m.entry_year
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryYear returns the old "entry_year" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldEntryYear(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryYear: %w", err)
	}
	return oldValue.EntryYear, nil
}

// AddEntryYear adds i to the "entry_year" field.
func (m *ETCRecordMutation) AddEntryYear(i int32) {
	if m.addentry_year != nil {
		*m.addentry_year += i
	} else {
		m.addentry_year = &i
	}
}

// AddedEntryYear returns the value that was added to the "entry_year" field in this mutation.
func (m *ETCRecordMutation) AddedEntryYear() (r int32, exists bool) {
	v := m.addentry_year
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntryYear resets all changes to the "entry_year" field.
func (m *ETCRecordMutation) ResetEntryYear() {
	m.entry_year = nil
	m.addentry_year = nil
}

// SetEntryMonth sets the "entry_month" field.
func (m *ETCRecordMutation) SetEntryMonth(i int32) {
	m.entry_month = &i
	m.addentry_month = nil
}

// EntryMonth returns the value of the "entry_month" field in the mutation.
func (m *ETCRecordMutation) EntryMonth() (r int32, exists bool) {
	v := m.entry_month
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryMonth returns the old "entry_month" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldEntryMonth(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryMonth: %w", err)
	}
	return oldValue.EntryMonth, nil
}

// AddEntryMonth adds i to the "entry_month" field.
func (m *ETCRecordMutation) AddEntryMonth(i int32) {
	if m.addentry_month != nil {
		*m.addentry_month += i
	} else {
		m.addentry_month = &i
	}
}

// AddedEntryMonth returns the value that was added to the "entry_month" field in this mutation.
func (m *ETCRecordMutation) AddedEntryMonth() (r int32, exists bool) {
	v := m.addentry_month
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntryMonth resets all changes to the "entry_month" field.
func (m *ETCRecordMutation) ResetEntryMonth() {
	m.entry_month = nil
	m.addentry_month = nil
}

// SetEntryDay sets the "entry_day" field.
func (m *ETCRecordMutation) SetEntryDay(i int32) {
	m.entry_day = &i
	m.addentry_day = nil
}

// EntryDay returns the value of the "entry_day" field in the mutation.
func (m *ETCRecordMutation) EntryDay() (r int32, exists bool) {
	v := m.entry_day
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryDay returns the old "entry_day" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldEntryDay(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryDay: %w", err)
	}
	return oldValue.EntryDay, nil
}

// AddEntryDay adds i to the "entry_day" field.
func (m *ETCRecordMutation) AddEntryDay(i int32) {
	if m.addentry_day != nil {
		*m.addentry_day += i
	} else {
		m.addentry_day = &i
	}
}

// AddedEntryDay returns the value that was added to the "entry_day" field in this mutation.
func (m *ETCRecordMutation) AddedEntryDay() (r int32, exists bool) {
	v := m.addentry_day
	if v == nil {
		return
	}
	return *v, true
}

// ResetEntryDay resets all changes to the "entry_day" field.
func (m *ETCRecordMutation) ResetEntryDay() {
	m.entry_day = nil
	m.addentry_day = nil
}

// SetExit sets the "exit" field.
func (m *ETCRecordMutation) SetExit(s string) {
	m.exit = &s
}

// Exit returns the value of the "exit" field in the mutation.
func (m *ETCRecordMutation) Exit() (r string, exists bool) {
	v := m.exit
	if v == nil {
		return
	}
	return *v, true
}

// OldExit returns the old "exit" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldExit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExit: %w", err)
	}
	return oldValue.Exit, nil
}

// ResetExit resets all changes to the "exit" field.
func (m *ETCRecordMutation) ResetExit() {
	m.exit = nil
}

// SetExitDate sets the "exit_date" field.
func (m *ETCRecordMutation) SetExitDate(s string) {
	m.exit_date = &s
}

// ExitDate returns the value of the "exit_date" field in the mutation.
func (m *ETCRecordMutation) ExitDate() (r string, exists bool) {
	v := m.exit_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExitDate returns the old "exit_date" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldExitDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExitDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExitDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExitDate: %w", err)
	}
	return oldValue.ExitDate, nil
}

// ResetExitDate resets all changes to the "exit_date" field.
func (m *ETCRecordMutation) ResetExitDate() {
	m.exit_date = nil
}

// SetExitTime sets the "exit_time" field.
func (m *ETCRecordMutation) SetExitTime(s string) {
	m.exit_time = &s
}

// ExitTime returns the value of the "exit_time" field in the mutation.
func (m *ETCRecordMutation) ExitTime() (r string, exists bool) {
	v := m.exit_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExitTime returns the old "exit_time" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldExitTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExitTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExitTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExitTime: %w", err)
	}
	return oldValue.ExitTime, nil
}

// ResetExitTime resets all changes to the "exit_time" field.
func (m *ETCRecordMutation) ResetExitTime() {
	m.exit_time = nil
}

// SetTotalPrice sets the "total_price" field.
func (m *ETCRecordMutation) SetTotalPrice(i int32) {
	m.total_price = &i
	m.addtotal_price = nil
}

// TotalPrice returns the value of the "total_price" field in the mutation.
func (m *ETCRecordMutation) TotalPrice() (r int32, exists bool) {
	v := m.total_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPrice returns the old "total_price" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldTotalPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPrice: %w", err)
	}
	return oldValue.TotalPrice, nil
}

// AddTotalPrice adds i to the "total_price" field.
func (m *ETCRecordMutation) AddTotalPrice(i int32) {
	if m.addtotal_price != nil {
		*m.addtotal_price += i
	} else {
		m.addtotal_price = &i
	}
}

// AddedTotalPrice returns the value that was added to the "total_price" field in this mutation.
func (m *ETCRecordMutation) AddedTotalPrice() (r int32, exists bool) {
	v := m.addtotal_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPrice resets all changes to the "total_price" field.
func (m *ETCRecordMutation) ResetTotalPrice() {
	m.total_price = nil
	m.addtotal_price = nil
}

// SetDiscountPrice sets the "discount_price" field.
func (m *ETCRecordMutation) SetDiscountPrice(i int32) {
	m.discount_price = &i
	m.adddiscount_price = nil
}

// DiscountPrice returns the value of the "discount_price" field in the mutation.
func (m *ETCRecordMutation) DiscountPrice() (r int32, exists bool) {
	v := m.discount_price
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountPrice returns the old "discount_price" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldDiscountPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountPrice: %w", err)
	}
	return oldValue.DiscountPrice, nil
}

// AddDiscountPrice adds i to the "discount_price" field.
func (m *ETCRecordMutation) AddDiscountPrice(i int32) {
	if m.adddiscount_price != nil {
		*m.adddiscount_price += i
	} else {
		m.adddiscount_price = &i
	}
}

// AddedDiscountPrice returns the value that was added to the "discount_price" field in this mutation.
func (m *ETCRecordMutation) AddedDiscountPrice() (r int32, exists bool) {
	v := m.adddiscount_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscountPrice resets all changes to the "discount_price" field.
func (m *ETCRecordMutation) ResetDiscountPrice() {
	m.discount_price = nil
	m.adddiscount_price = nil
}

// SetPaidPrice sets the "paid_price" field.
func (m *ETCRecordMutation) SetPaidPrice(i int32) {
	m.paid_price = &i
	m.addpaid_price = nil
}

// PaidPrice returns the value of the "paid_price" field in the mutation.
func (m *ETCRecordMutation) PaidPrice() (r int32, exists bool) {
	v := m.paid_price
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidPrice returns the old "paid_price" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldPaidPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidPrice: %w", err)
	}
	return oldValue.PaidPrice, nil
}

// AddPaidPrice adds i to the "paid_price" field.
func (m *ETCRecordMutation) AddPaidPrice(i int32) {
	if m.addpaid_price != nil {
		*m.addpaid_price += i
	} else {
		m.addpaid_price = &i
	}
}

// AddedPaidPrice returns the value that was added to the "paid_price" field in this mutation.
func (m *ETCRecordMutation) AddedPaidPrice() (r int32, exists bool) {
	v := m.addpaid_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetPaidPrice resets all changes to the "paid_price" field.
func (m *ETCRecordMutation) ResetPaidPrice() {
	m.paid_price = nil
	m.addpaid_price = nil
}

// SetCarType sets the "car_type" field.
func (m *ETCRecordMutation) SetCarType(i int8) {
	m.car_type = &i
	m.addcar_type = nil
}

// CarType returns the value of the "car_type" field in the mutation.
func (m *ETCRecordMutation) CarType() (r int8, exists bool) {
	v := m.car_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCarType returns the old "car_type" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldCarType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarType: %w", err)
	}
	return oldValue.CarType, nil
}

// AddCarType adds i to the "car_type" field.
func (m *ETCRecordMutation) AddCarType(i int8) {
	if m.addcar_type != nil {
		*m.addcar_type += i
	} else {
		m.addcar_type = &i
	}
}

// AddedCarType returns the value that was added to the "car_type" field in this mutation.
func (m *ETCRecordMutation) AddedCarType() (r int8, exists bool) {
	v := m.addcar_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarType resets all changes to the "car_type" field.
func (m *ETCRecordMutation) ResetCarType() {
	m.car_type = nil
	m.addcar_type = nil
}

// SetCarNumber sets the "car_number" field.
func (m *ETCRecordMutation) SetCarNumber(s string) {
	m.car_number = &s
}

// CarNumber returns the value of the "car_number" field in the mutation.
func (m *ETCRecordMutation) CarNumber() (r string, exists bool) {
	v := m.car_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCarNumber returns the old "car_number" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldCarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarNumber: %w", err)
	}
	return oldValue.CarNumber, nil
}

// ResetCarNumber resets all changes to the "car_number" field.
func (m *ETCRecordMutation) ResetCarNumber() {
	m.car_number = nil
}

// SetCardNumber sets the "card_number" field.
func (m *ETCRecordMutation) SetCardNumber(s string) {
	m.card_number = &s
}

// CardNumber returns the value of the "card_number" field in the mutation.
func (m *ETCRecordMutation) CardNumber() (r string, exists bool) {
	v := m.card_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCardNumber returns the old "card_number" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardNumber: %w", err)
	}
	return oldValue.CardNumber, nil
}

// ResetCardNumber resets all changes to the "card_number" field.
func (m *ETCRecordMutation) ResetCardNumber() {
	m.card_number = nil
}

// SetStatus sets the "status" field.
func (m *ETCRecordMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ETCRecordMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ETCRecordMutation) ResetStatus() {
	m.status = nil
}

// SetComment sets the "comment" field.
func (m *ETCRecordMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *ETCRecordMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldComment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *ETCRecordMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[etcrecord.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *ETCRecordMutation) CommentCleared() bool {
	_, ok := m.clearedFields[etcrecord.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *ETCRecordMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, etcrecord.FieldComment)
}

// SetCreatedAt sets the "created_at" field.
func (m *ETCRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ETCRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ETCRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ETCRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ETCRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ETCRecord entity.
// If the ETCRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ETCRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ETCRecordMutation builder.
func (m *ETCRecordMutation) Where(ps ...predicate.ETCRecord) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ETCRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ETCRecord).
func (m *ETCRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ETCRecordMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.username != nil {
		fields = append(fields, etcrecord.FieldUsername)
	}
	if m.entry != nil {
		fields = append(fields, etcrecord.FieldEntry)
	}
	if m.entry_year != nil {
		fields = append(fields, etcrecord.FieldEntryYear)
	}
	if m.entry_month != nil {
		fields = append(fields, etcrecord.FieldEntryMonth)
	}
	if m.entry_day != nil {
		fields = append(fields, etcrecord.FieldEntryDay)
	}
	if m.exit != nil {
		fields = append(fields, etcrecord.FieldExit)
	}
	if m.exit_date != nil {
		fields = append(fields, etcrecord.FieldExitDate)
	}
	if m.exit_time != nil {
		fields = append(fields, etcrecord.FieldExitTime)
	}
	if m.total_price != nil {
		fields = append(fields, etcrecord.FieldTotalPrice)
	}
	if m.discount_price != nil {
		fields = append(fields, etcrecord.FieldDiscountPrice)
	}
	if m.paid_price != nil {
		fields = append(fields, etcrecord.FieldPaidPrice)
	}
	if m.car_type != nil {
		fields = append(fields, etcrecord.FieldCarType)
	}
	if m.car_number != nil {
		fields = append(fields, etcrecord.FieldCarNumber)
	}
	if m.card_number != nil {
		fields = append(fields, etcrecord.FieldCardNumber)
	}
	if m.status != nil {
		fields = append(fields, etcrecord.FieldStatus)
	}
	if m.comment != nil {
		fields = append(fields, etcrecord.FieldComment)
	}
	if m.created_at != nil {
		fields = append(fields, etcrecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, etcrecord.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ETCRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case etcrecord.FieldUsername:
		return m.Username()
	case etcrecord.FieldEntry:
		return m.Entry()
	case etcrecord.FieldEntryYear:
		return m.EntryYear()
	case etcrecord.FieldEntryMonth:
		return m.EntryMonth()
	case etcrecord.FieldEntryDay:
		return m.EntryDay()
	case etcrecord.FieldExit:
		return m.Exit()
	case etcrecord.FieldExitDate:
		return m.ExitDate()
	case etcrecord.FieldExitTime:
		return m.ExitTime()
	case etcrecord.FieldTotalPrice:
		return m.TotalPrice()
	case etcrecord.FieldDiscountPrice:
		return m.DiscountPrice()
	case etcrecord.FieldPaidPrice:
		return m.PaidPrice()
	case etcrecord.FieldCarType:
		return m.CarType()
	case etcrecord.FieldCarNumber:
		return m.CarNumber()
	case etcrecord.FieldCardNumber:
		return m.CardNumber()
	case etcrecord.FieldStatus:
		return m.Status()
	case etcrecord.FieldComment:
		return m.Comment()
	case etcrecord.FieldCreatedAt:
		return m.CreatedAt()
	case etcrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ETCRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case etcrecord.FieldUsername:
		return m.OldUsername(ctx)
	case etcrecord.FieldEntry:
		return m.OldEntry(ctx)
	case etcrecord.FieldEntryYear:
		return m.OldEntryYear(ctx)
	case etcrecord.FieldEntryMonth:
		return m.OldEntryMonth(ctx)
	case etcrecord.FieldEntryDay:
		return m.OldEntryDay(ctx)
	case etcrecord.FieldExit:
		return m.OldExit(ctx)
	case etcrecord.FieldExitDate:
		return m.OldExitDate(ctx)
	case etcrecord.FieldExitTime:
		return m.OldExitTime(ctx)
	case etcrecord.FieldTotalPrice:
		return m.OldTotalPrice(ctx)
	case etcrecord.FieldDiscountPrice:
		return m.OldDiscountPrice(ctx)
	case etcrecord.FieldPaidPrice:
		return m.OldPaidPrice(ctx)
	case etcrecord.FieldCarType:
		return m.OldCarType(ctx)
	case etcrecord.FieldCarNumber:
		return m.OldCarNumber(ctx)
	case etcrecord.FieldCardNumber:
		return m.OldCardNumber(ctx)
	case etcrecord.FieldStatus:
		return m.OldStatus(ctx)
	case etcrecord.FieldComment:
		return m.OldComment(ctx)
	case etcrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case etcrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ETCRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ETCRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case etcrecord.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case etcrecord.FieldEntry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntry(v)
		return nil
	case etcrecord.FieldEntryYear:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryYear(v)
		return nil
	case etcrecord.FieldEntryMonth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryMonth(v)
		return nil
	case etcrecord.FieldEntryDay:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryDay(v)
		return nil
	case etcrecord.FieldExit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExit(v)
		return nil
	case etcrecord.FieldExitDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExitDate(v)
		return nil
	case etcrecord.FieldExitTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExitTime(v)
		return nil
	case etcrecord.FieldTotalPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPrice(v)
		return nil
	case etcrecord.FieldDiscountPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountPrice(v)
		return nil
	case etcrecord.FieldPaidPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidPrice(v)
		return nil
	case etcrecord.FieldCarType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarType(v)
		return nil
	case etcrecord.FieldCarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarNumber(v)
		return nil
	case etcrecord.FieldCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardNumber(v)
		return nil
	case etcrecord.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case etcrecord.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case etcrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case etcrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ETCRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ETCRecordMutation) AddedFields() []string {
	var fields []string
	if m.addentry_year != nil {
		fields = append(fields, etcrecord.FieldEntryYear)
	}
	if m.addentry_month != nil {
		fields = append(fields, etcrecord.FieldEntryMonth)
	}
	if m.addentry_day != nil {
		fields = append(fields, etcrecord.FieldEntryDay)
	}
	if m.addtotal_price != nil {
		fields = append(fields, etcrecord.FieldTotalPrice)
	}
	if m.adddiscount_price != nil {
		fields = append(fields, etcrecord.FieldDiscountPrice)
	}
	if m.addpaid_price != nil {
		fields = append(fields, etcrecord.FieldPaidPrice)
	}
	if m.addcar_type != nil {
		fields = append(fields, etcrecord.FieldCarType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ETCRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case etcrecord.FieldEntryYear:
		return m.AddedEntryYear()
	case etcrecord.FieldEntryMonth:
		return m.AddedEntryMonth()
	case etcrecord.FieldEntryDay:
		return m.AddedEntryDay()
	case etcrecord.FieldTotalPrice:
		return m.AddedTotalPrice()
	case etcrecord.FieldDiscountPrice:
		return m.AddedDiscountPrice()
	case etcrecord.FieldPaidPrice:
		return m.AddedPaidPrice()
	case etcrecord.FieldCarType:
		return m.AddedCarType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ETCRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case etcrecord.FieldEntryYear:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntryYear(v)
		return nil
	case etcrecord.FieldEntryMonth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntryMonth(v)
		return nil
	case etcrecord.FieldEntryDay:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEntryDay(v)
		return nil
	case etcrecord.FieldTotalPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPrice(v)
		return nil
	case etcrecord.FieldDiscountPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountPrice(v)
		return nil
	case etcrecord.FieldPaidPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaidPrice(v)
		return nil
	case etcrecord.FieldCarType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarType(v)
		return nil
	}
	return fmt.Errorf("unknown ETCRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ETCRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(etcrecord.FieldComment) {
		fields = append(fields, etcrecord.FieldComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ETCRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ETCRecordMutation) ClearField(name string) error {
	switch name {
	case etcrecord.FieldComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown ETCRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ETCRecordMutation) ResetField(name string) error {
	switch name {
	case etcrecord.FieldUsername:
		m.ResetUsername()
		return nil
	case etcrecord.FieldEntry:
		m.ResetEntry()
		return nil
	case etcrecord.FieldEntryYear:
		m.ResetEntryYear()
		return nil
	case etcrecord.FieldEntryMonth:
		m.ResetEntryMonth()
		return nil
	case etcrecord.FieldEntryDay:
		m.ResetEntryDay()
		return nil
	case etcrecord.FieldExit:
		m.ResetExit()
		return nil
	case etcrecord.FieldExitDate:
		m.ResetExitDate()
		return nil
	case etcrecord.FieldExitTime:
		m.ResetExitTime()
		return nil
	case etcrecord.FieldTotalPrice:
		m.ResetTotalPrice()
		return nil
	case etcrecord.FieldDiscountPrice:
		m.ResetDiscountPrice()
		return nil
	case etcrecord.FieldPaidPrice:
		m.ResetPaidPrice()
		return nil
	case etcrecord.FieldCarType:
		m.ResetCarType()
		return nil
	case etcrecord.FieldCarNumber:
		m.ResetCarNumber()
		return nil
	case etcrecord.FieldCardNumber:
		m.ResetCardNumber()
		return nil
	case etcrecord.FieldStatus:
		m.ResetStatus()
		return nil
	case etcrecord.FieldComment:
		m.ResetComment()
		return nil
	case etcrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case etcrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ETCRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ETCRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ETCRecordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ETCRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ETCRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ETCRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ETCRecordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ETCRecordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ETCRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ETCRecordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ETCRecord edge %s", name)
}

// ETCSyncRecordMutation represents an operation that mutates the ETCSyncRecord nodes in the graph.
type ETCSyncRecordMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	username      *string
	sync_data     *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ETCSyncRecord, error)
	predicates    []predicate.ETCSyncRecord
}

var _ ent.Mutation = (*ETCSyncRecordMutation)(nil)

// etcsyncrecordOption allows management of the mutation configuration using functional options.
type etcsyncrecordOption func(*ETCSyncRecordMutation)

// newETCSyncRecordMutation creates new mutation for the ETCSyncRecord entity.
func newETCSyncRecordMutation(c config, op Op, opts ...etcsyncrecordOption) *ETCSyncRecordMutation {
	m := &ETCSyncRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeETCSyncRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withETCSyncRecordID sets the ID field of the mutation.
func withETCSyncRecordID(id int64) etcsyncrecordOption {
	return func(m *ETCSyncRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *ETCSyncRecord
		)
		m.oldValue = func(ctx context.Context) (*ETCSyncRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ETCSyncRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withETCSyncRecord sets the old ETCSyncRecord of the mutation.
func withETCSyncRecord(node *ETCSyncRecord) etcsyncrecordOption {
	return func(m *ETCSyncRecordMutation) {
		m.oldValue = func(context.Context) (*ETCSyncRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ETCSyncRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ETCSyncRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ETCSyncRecord entities.
func (m *ETCSyncRecordMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ETCSyncRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ETCSyncRecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ETCSyncRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *ETCSyncRecordMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ETCSyncRecordMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the ETCSyncRecord entity.
// If the ETCSyncRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCSyncRecordMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *ETCSyncRecordMutation) ResetUsername() {
	m.username = nil
}

// SetSyncData sets the "sync_data" field.
func (m *ETCSyncRecordMutation) SetSyncData(s string) {
	m.sync_data = &s
}

// SyncData returns the value of the "sync_data" field in the mutation.
func (m *ETCSyncRecordMutation) SyncData() (r string, exists bool) {
	v := m.sync_data
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncData returns the old "sync_data" field's value of the ETCSyncRecord entity.
// If the ETCSyncRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCSyncRecordMutation) OldSyncData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncData: %w", err)
	}
	return oldValue.SyncData, nil
}

// ResetSyncData resets all changes to the "sync_data" field.
func (m *ETCSyncRecordMutation) ResetSyncData() {
	m.sync_data = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ETCSyncRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ETCSyncRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ETCSyncRecord entity.
// If the ETCSyncRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCSyncRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ETCSyncRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ETCSyncRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ETCSyncRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ETCSyncRecord entity.
// If the ETCSyncRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCSyncRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ETCSyncRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ETCSyncRecordMutation builder.
func (m *ETCSyncRecordMutation) Where(ps ...predicate.ETCSyncRecord) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ETCSyncRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ETCSyncRecord).
func (m *ETCSyncRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ETCSyncRecordMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.username != nil {
		fields = append(fields, etcsyncrecord.FieldUsername)
	}
	if m.sync_data != nil {
		fields = append(fields, etcsyncrecord.FieldSyncData)
	}
	if m.created_at != nil {
		fields = append(fields, etcsyncrecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, etcsyncrecord.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ETCSyncRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case etcsyncrecord.FieldUsername:
		return m.Username()
	case etcsyncrecord.FieldSyncData:
		return m.SyncData()
	case etcsyncrecord.FieldCreatedAt:
		return m.CreatedAt()
	case etcsyncrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ETCSyncRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case etcsyncrecord.FieldUsername:
		return m.OldUsername(ctx)
	case etcsyncrecord.FieldSyncData:
		return m.OldSyncData(ctx)
	case etcsyncrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case etcsyncrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ETCSyncRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ETCSyncRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case etcsyncrecord.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case etcsyncrecord.FieldSyncData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncData(v)
		return nil
	case etcsyncrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case etcsyncrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ETCSyncRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ETCSyncRecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ETCSyncRecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ETCSyncRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ETCSyncRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ETCSyncRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ETCSyncRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ETCSyncRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ETCSyncRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ETCSyncRecordMutation) ResetField(name string) error {
	switch name {
	case etcsyncrecord.FieldUsername:
		m.ResetUsername()
		return nil
	case etcsyncrecord.FieldSyncData:
		m.ResetSyncData()
		return nil
	case etcsyncrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case etcsyncrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ETCSyncRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ETCSyncRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ETCSyncRecordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ETCSyncRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ETCSyncRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ETCSyncRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ETCSyncRecordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ETCSyncRecordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ETCSyncRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ETCSyncRecordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ETCSyncRecord edge %s", name)
}

// ETCUserMutation represents an operation that mutates the ETCUser nodes in the graph.
type ETCUserMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	etc_username    *int64
	addetc_username *int64
	etc_password    *string
	point_username  *string
	point_password  *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ETCUser, error)
	predicates      []predicate.ETCUser
}

var _ ent.Mutation = (*ETCUserMutation)(nil)

// etcuserOption allows management of the mutation configuration using functional options.
type etcuserOption func(*ETCUserMutation)

// newETCUserMutation creates new mutation for the ETCUser entity.
func newETCUserMutation(c config, op Op, opts ...etcuserOption) *ETCUserMutation {
	m := &ETCUserMutation{
		config:        c,
		op:            op,
		typ:           TypeETCUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withETCUserID sets the ID field of the mutation.
func withETCUserID(id int64) etcuserOption {
	return func(m *ETCUserMutation) {
		var (
			err   error
			once  sync.Once
			value *ETCUser
		)
		m.oldValue = func(ctx context.Context) (*ETCUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ETCUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withETCUser sets the old ETCUser of the mutation.
func withETCUser(node *ETCUser) etcuserOption {
	return func(m *ETCUserMutation) {
		m.oldValue = func(context.Context) (*ETCUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ETCUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ETCUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ETCUser entities.
func (m *ETCUserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ETCUserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ETCUserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ETCUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEtcUsername sets the "etc_username" field.
func (m *ETCUserMutation) SetEtcUsername(i int64) {
	m.etc_username = &i
	m.addetc_username = nil
}

// EtcUsername returns the value of the "etc_username" field in the mutation.
func (m *ETCUserMutation) EtcUsername() (r int64, exists bool) {
	v := m.etc_username
	if v == nil {
		return
	}
	return *v, true
}

// OldEtcUsername returns the old "etc_username" field's value of the ETCUser entity.
// If the ETCUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCUserMutation) OldEtcUsername(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtcUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtcUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtcUsername: %w", err)
	}
	return oldValue.EtcUsername, nil
}

// AddEtcUsername adds i to the "etc_username" field.
func (m *ETCUserMutation) AddEtcUsername(i int64) {
	if m.addetc_username != nil {
		*m.addetc_username += i
	} else {
		m.addetc_username = &i
	}
}

// AddedEtcUsername returns the value that was added to the "etc_username" field in this mutation.
func (m *ETCUserMutation) AddedEtcUsername() (r int64, exists bool) {
	v := m.addetc_username
	if v == nil {
		return
	}
	return *v, true
}

// ResetEtcUsername resets all changes to the "etc_username" field.
func (m *ETCUserMutation) ResetEtcUsername() {
	m.etc_username = nil
	m.addetc_username = nil
}

// SetEtcPassword sets the "etc_password" field.
func (m *ETCUserMutation) SetEtcPassword(s string) {
	m.etc_password = &s
}

// EtcPassword returns the value of the "etc_password" field in the mutation.
func (m *ETCUserMutation) EtcPassword() (r string, exists bool) {
	v := m.etc_password
	if v == nil {
		return
	}
	return *v, true
}

// OldEtcPassword returns the old "etc_password" field's value of the ETCUser entity.
// If the ETCUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCUserMutation) OldEtcPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEtcPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEtcPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtcPassword: %w", err)
	}
	return oldValue.EtcPassword, nil
}

// ResetEtcPassword resets all changes to the "etc_password" field.
func (m *ETCUserMutation) ResetEtcPassword() {
	m.etc_password = nil
}

// SetPointUsername sets the "point_username" field.
func (m *ETCUserMutation) SetPointUsername(s string) {
	m.point_username = &s
}

// PointUsername returns the value of the "point_username" field in the mutation.
func (m *ETCUserMutation) PointUsername() (r string, exists bool) {
	v := m.point_username
	if v == nil {
		return
	}
	return *v, true
}

// OldPointUsername returns the old "point_username" field's value of the ETCUser entity.
// If the ETCUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCUserMutation) OldPointUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointUsername: %w", err)
	}
	return oldValue.PointUsername, nil
}

// ResetPointUsername resets all changes to the "point_username" field.
func (m *ETCUserMutation) ResetPointUsername() {
	m.point_username = nil
}

// SetPointPassword sets the "point_password" field.
func (m *ETCUserMutation) SetPointPassword(s string) {
	m.point_password = &s
}

// PointPassword returns the value of the "point_password" field in the mutation.
func (m *ETCUserMutation) PointPassword() (r string, exists bool) {
	v := m.point_password
	if v == nil {
		return
	}
	return *v, true
}

// OldPointPassword returns the old "point_password" field's value of the ETCUser entity.
// If the ETCUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCUserMutation) OldPointPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointPassword: %w", err)
	}
	return oldValue.PointPassword, nil
}

// ResetPointPassword resets all changes to the "point_password" field.
func (m *ETCUserMutation) ResetPointPassword() {
	m.point_password = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ETCUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ETCUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ETCUser entity.
// If the ETCUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ETCUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ETCUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ETCUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ETCUser entity.
// If the ETCUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ETCUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ETCUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ETCUserMutation builder.
func (m *ETCUserMutation) Where(ps ...predicate.ETCUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ETCUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ETCUser).
func (m *ETCUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ETCUserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.etc_username != nil {
		fields = append(fields, etcuser.FieldEtcUsername)
	}
	if m.etc_password != nil {
		fields = append(fields, etcuser.FieldEtcPassword)
	}
	if m.point_username != nil {
		fields = append(fields, etcuser.FieldPointUsername)
	}
	if m.point_password != nil {
		fields = append(fields, etcuser.FieldPointPassword)
	}
	if m.created_at != nil {
		fields = append(fields, etcuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, etcuser.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ETCUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case etcuser.FieldEtcUsername:
		return m.EtcUsername()
	case etcuser.FieldEtcPassword:
		return m.EtcPassword()
	case etcuser.FieldPointUsername:
		return m.PointUsername()
	case etcuser.FieldPointPassword:
		return m.PointPassword()
	case etcuser.FieldCreatedAt:
		return m.CreatedAt()
	case etcuser.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ETCUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case etcuser.FieldEtcUsername:
		return m.OldEtcUsername(ctx)
	case etcuser.FieldEtcPassword:
		return m.OldEtcPassword(ctx)
	case etcuser.FieldPointUsername:
		return m.OldPointUsername(ctx)
	case etcuser.FieldPointPassword:
		return m.OldPointPassword(ctx)
	case etcuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case etcuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ETCUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ETCUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case etcuser.FieldEtcUsername:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtcUsername(v)
		return nil
	case etcuser.FieldEtcPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtcPassword(v)
		return nil
	case etcuser.FieldPointUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointUsername(v)
		return nil
	case etcuser.FieldPointPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointPassword(v)
		return nil
	case etcuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case etcuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ETCUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ETCUserMutation) AddedFields() []string {
	var fields []string
	if m.addetc_username != nil {
		fields = append(fields, etcuser.FieldEtcUsername)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ETCUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case etcuser.FieldEtcUsername:
		return m.AddedEtcUsername()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ETCUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case etcuser.FieldEtcUsername:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEtcUsername(v)
		return nil
	}
	return fmt.Errorf("unknown ETCUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ETCUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ETCUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ETCUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ETCUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ETCUserMutation) ResetField(name string) error {
	switch name {
	case etcuser.FieldEtcUsername:
		m.ResetEtcUsername()
		return nil
	case etcuser.FieldEtcPassword:
		m.ResetEtcPassword()
		return nil
	case etcuser.FieldPointUsername:
		m.ResetPointUsername()
		return nil
	case etcuser.FieldPointPassword:
		m.ResetPointPassword()
		return nil
	case etcuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case etcuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ETCUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ETCUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ETCUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ETCUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ETCUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ETCUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ETCUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ETCUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ETCUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ETCUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ETCUser edge %s", name)
}
